import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Like } from 'typeorm';
import { v4 as uuidv4 } from 'uuid';
import { HaimianApiService } from './haimian-api.service';
import { BusinessConfigService } from '../business-config/business-config.service';
import { TeacherService } from '../teacher/teacher.service';
import { OrderSyncLog } from './entities/order-sync-log.entity';
import { Order } from '../order/entities/order.entity';
import { Customer } from '../customer/entities/customer.entity';
import { Campus } from '../system/entities/campus.entity';
import { HaimianOrder } from './interfaces/haimian-order.interface';
import { SyncResultDto, SyncLogQueryDto } from './dto/sync-result.dto';

@Injectable()
export class OrderSyncService {
  private readonly logger = new Logger(OrderSyncService.name);

  constructor(
    @InjectRepository(OrderSyncLog)
    private readonly syncLogRepository: Repository<OrderSyncLog>,
    @InjectRepository(Order)
    private readonly orderRepository: Repository<Order>,
    @InjectRepository(Customer)
    private readonly customerRepository: Repository<Customer>,
    @InjectRepository(Campus)
    private readonly campusRepository: Repository<Campus>,
    private readonly haimianApiService: HaimianApiService,
    private readonly businessConfigService: BusinessConfigService,
    private readonly teacherService: TeacherService,
  ) {}

  /**
   * 手动触发同步
   */
  async triggerSync(params?: {
    startTime?: string;
    endTime?: string;
    status?: number;
  }): Promise<SyncResultDto> {
    const syncBatchId = uuidv4();
    const startTime = Date.now();

    this.logger.log(`开始手动同步，批次ID: ${syncBatchId}`);

    try {
      // 获取配置 - 默认同步6小时的数据避免超时
      const syncRangeHoursConfig = await this.businessConfigService.getConfig('order_sync.sync_range_hours') || '6';
      const syncRangeHours = !isNaN(parseInt(syncRangeHoursConfig)) ? parseInt(syncRangeHoursConfig) : 6;

      // 计算时间范围（如果未指定）
      const endDate = params?.endTime || this.formatDate(new Date());
      const startDate =
        params?.startTime ||
        this.formatDate(new Date(Date.now() - syncRangeHours * 60 * 60 * 1000));

      // 获取海绵订单数据
      const haimianOrders = await this.haimianApiService.getAllOrders({
        startTime: startDate,
        endTime: endDate,
        status: params?.status,
      });

      // 过滤掉status=1（未支付）的订单
      const ordersToSync = haimianOrders.filter(order => order.status !== 1);

      this.logger.log(`获取到 ${ordersToSync.length} 条待同步订单（已过滤未支付订单）`);

      // 执行同步
      const result = await this.syncOrders(ordersToSync, syncBatchId);

      const executionTime = Date.now() - startTime;
      result.executionTime = executionTime;

      this.logger.log(
        `同步完成，批次ID: ${syncBatchId}，` +
          `成功: ${result.successCount}，失败: ${result.failedCount}，` +
          `耗时: ${executionTime}ms`,
      );

      return result;
    } catch (error) {
      this.logger.error(`同步失败: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * 执行订单同步
   */
  private async syncOrders(
    haimianOrders: HaimianOrder[],
    syncBatchId: string,
  ): Promise<SyncResultDto> {
    const result: SyncResultDto = {
      syncBatchId,
      totalProcessed: haimianOrders.length,
      successCount: 0,
      failedCount: 0,
      skippedCount: 0,
      createdCount: 0,
      updatedCount: 0,
      deletedCount: 0,
      executionTime: 0,
      errors: [],
    };

    const updateExistingConfig = await this.businessConfigService.getConfig('order_sync.update_existing');
    const syncCustomerInfoConfig = await this.businessConfigService.getConfig('order_sync.sync_customer_info');
    const autoCreateCampusConfig = await this.businessConfigService.getConfig('order_sync.auto_create_campus');

    // 安全处理配置值，避免在undefined值上调用replace方法
    const updateExisting = (updateExistingConfig && typeof updateExistingConfig === 'string' ? updateExistingConfig.replace(/"/g, '') : '') === 'true';
    const syncCustomerInfo = (syncCustomerInfoConfig && typeof syncCustomerInfoConfig === 'string' ? syncCustomerInfoConfig.replace(/"/g, '') : '') === 'true';
    const autoCreateCampus = (autoCreateCampusConfig && typeof autoCreateCampusConfig === 'string' ? autoCreateCampusConfig.replace(/"/g, '') : '') === 'true';

    for (const haimianOrder of haimianOrders) {
      const orderStartTime = Date.now();
      try {
        // 查找本地订单
        const existingOrder = await this.orderRepository.findOne({
          where: { orderNo: haimianOrder.order_id.toString() },
        });

        if (existingOrder) {
          // 订单已存在
          if (!updateExisting) {
            // 跳过已存在的订单
            await this.logSync({
              syncBatchId,
              orderNo: haimianOrder.order_id.toString(),
              syncType: 'skip',
              oldStatus: existingOrder.orderStatus,
              newStatus: null,
              externalData: haimianOrder,
              result: 'success',
              executionTime: Date.now() - orderStartTime,
            });
            result.skippedCount++;
            result.successCount++;
            continue;
          }

          // 更新订单
          const updated = await this.updateOrder(existingOrder, haimianOrder, syncBatchId, orderStartTime);
          if (updated) {
            result.updatedCount++;
            result.successCount++;
          } else {
            result.skippedCount++;
            result.successCount++;
          }
        } else {
          // 创建新订单
          await this.createOrder(haimianOrder, syncBatchId, orderStartTime, {
            syncCustomerInfo,
            autoCreateCampus,
          });
          result.createdCount++;
          result.successCount++;
        }
      } catch (error) {
        this.logger.error(`处理订单 ${haimianOrder.order_id} 失败: ${error.message}`);
        result.failedCount++;
        result.errors.push({
          orderNo: haimianOrder.order_id.toString(),
          message: error.message,
        });

        await this.logSync({
          syncBatchId,
          orderNo: haimianOrder.order_id.toString(),
          syncType: 'create',
          result: 'failed',
          errorMessage: error.message,
          externalData: haimianOrder,
          executionTime: Date.now() - orderStartTime,
        });
      }
    }

    return result;
  }

  /**
   * 创建新订单
   */
  private async createOrder(
    haimianOrder: HaimianOrder,
    syncBatchId: string,
    startTime: number,
    options: { syncCustomerInfo: boolean; autoCreateCampus: boolean },
  ): Promise<void> {
    // 查找或创建校区
    let campus = await this.campusRepository.findOne({
      where: { campusName: haimianOrder.store_name },
    });

    if (!campus && options.autoCreateCampus) {
      campus = this.campusRepository.create({
        campusName: haimianOrder.store_name,
        campusCode: `AUTO_${Date.now()}`, // 自动生成校区编码
        address: haimianOrder.store_name, // 将店铺名作为地址
        status: 1, // 启用
      });
      await this.campusRepository.save(campus);
      this.logger.log(`自动创建校区: ${haimianOrder.store_name}`);
    }

    if (!campus) {
      throw new Error(`校区不存在: ${haimianOrder.store_name}`);
    }

    // 直接创建或查找客户（简化逻辑）
    const customer = await this.findOrCreateCustomer(haimianOrder, options);

    // 创建或查找老师
    let teacher = null;
    if (haimianOrder.coach_name) {
      teacher = await this.teacherService.findOrCreateTeacher({
        teacherId: haimianOrder.coach_id.toString(),
        teacherName: haimianOrder.coach_name,
        campusName: haimianOrder.store_name,
        sourceSystem: '海绵青年GO',
      });
    }

    // 计算订单状态
    const orderStatus = this.mapOrderStatus(haimianOrder);

    // 合并课程名称（多商品）
    const courseName = haimianOrder.skus.map(sku => sku.goods_name).join('、');

    // 获取默认销售ID
    const defaultSalesIdConfig = await this.businessConfigService.getConfig('order_sync.default_sales_id') || '1';
    const defaultSalesId = !isNaN(parseInt(defaultSalesIdConfig)) ? parseInt(defaultSalesIdConfig) : 1;

    // 计算老师提成
    const teacherCommission = haimianOrder.amount && haimianOrder.is_commission === 1 && !isNaN(parseFloat(haimianOrder.amount))
      ? parseFloat(haimianOrder.amount)
      : 0;

    // 创建订单
    const order = this.orderRepository.create({
      orderNo: haimianOrder.order_id.toString(),
      customerId: customer.id,
      campusId: campus.id,
      courseName,
      teacherName: haimianOrder.coach_name || '', // 使用海绵的老师姓名
      teacherId: haimianOrder.coach_id && !isNaN(parseInt(haimianOrder.coach_id.toString())) ? parseInt(haimianOrder.coach_id.toString()) : null, // 设置老师ID
      paymentAmount: haimianOrder.need_pay && !isNaN(parseFloat(haimianOrder.need_pay)) ? parseFloat(haimianOrder.need_pay) : 0,
      paymentTime: this.parseHaimianDateTime(haimianOrder.pay_time.toString()),
      orderStatus,
      salesId: defaultSalesId,
      dataSource: '海绵青年GO',
      isExternal: 1,
      externalSystem: 'HAIMIAN',
      externalStatus: haimianOrder.status != null ? haimianOrder.status : null,
      externalRefund: haimianOrder.refund != null ? haimianOrder.refund : null,
      externalRefundStatus: haimianOrder.refund_status != null ? haimianOrder.refund_status : null,
      // 老师提成相关字段
      teacherCommission,
      syncStatus: '已同步',
      lastSyncTime: new Date(),
      isDeleted: 0,
      remark: haimianOrder.remark || '',
    });

    await this.orderRepository.save(order);

    // 更新老师统计信息
    if (teacher && teacherCommission > 0) {
      await this.teacherService.updateTeacherStats(teacher.name, teacherCommission);
    }

    // 记录同步日志，包含老师提成信息
    await this.logSync({
      syncBatchId,
      orderNo: haimianOrder.order_id.toString(),
      syncType: 'create',
      newStatus: orderStatus,
      externalData: {
        ...haimianOrder,
        teacherCommission: haimianOrder.amount && !isNaN(parseFloat(haimianOrder.amount)) ? parseFloat(haimianOrder.amount) : 0,
      },
      result: 'success',
      executionTime: Date.now() - startTime,
    });

    this.logger.log(`创建订单成功: ${haimianOrder.order_id}，老师提成: ${haimianOrder.amount || '0'}`);
  }

  /**
   * 更新订单
   */
  private async updateOrder(
    existingOrder: Order,
    haimianOrder: HaimianOrder,
    syncBatchId: string,
    startTime: number,
  ): Promise<boolean> {
    const newStatus = this.mapOrderStatus(haimianOrder);
    const oldStatus = existingOrder.orderStatus;

    // 检测变更
    const changes: any = {};
    let hasChanges = false;

    if (newStatus !== oldStatus) {
      changes.orderStatus = { old: oldStatus, new: newStatus };
      hasChanges = true;
    }

    const haimianStatus = haimianOrder.status != null ? haimianOrder.status : null;
    const haimianRefund = haimianOrder.refund != null ? haimianOrder.refund : null;
    const haimianRefundStatus = haimianOrder.refund_status != null ? haimianOrder.refund_status : null;

    if (haimianStatus !== existingOrder.externalStatus) {
      changes.externalStatus = { old: existingOrder.externalStatus, new: haimianStatus };
      hasChanges = true;
    }

    if (haimianRefund !== existingOrder.externalRefund) {
      changes.externalRefund = { old: existingOrder.externalRefund, new: haimianRefund };
      hasChanges = true;
    }

    if (haimianRefundStatus !== existingOrder.externalRefundStatus) {
      changes.externalRefundStatus = {
        old: existingOrder.externalRefundStatus,
        new: haimianRefundStatus,
      };
      hasChanges = true;
    }

    if (!hasChanges) {
      // 无变化，跳过
      await this.logSync({
        syncBatchId,
        orderNo: haimianOrder.order_id,
        syncType: 'skip',
        oldStatus,
        newStatus: oldStatus,
        externalData: haimianOrder,
        result: 'success',
        executionTime: Date.now() - startTime,
      });
      return false;
    }

    // 更新订单
    existingOrder.orderStatus = newStatus;
    existingOrder.externalStatus = haimianStatus;
    existingOrder.externalRefund = haimianRefund;
    existingOrder.externalRefundStatus = haimianRefundStatus;
    existingOrder.lastSyncTime = new Date();
    existingOrder.syncStatus = '已同步';

    await this.orderRepository.save(existingOrder);

    // 记录日志
    await this.logSync({
      syncBatchId,
      orderNo: haimianOrder.order_id.toString(),
      syncType: 'update',
      oldStatus,
      newStatus,
      changes,
      externalData: haimianOrder,
      result: 'success',
      executionTime: Date.now() - startTime,
    });

    this.logger.log(`更新订单成功: ${haimianOrder.order_id}，状态: ${oldStatus} -> ${newStatus}`);
    return true;
  }

  /**
   * 映射订单状态
   * 规则：
   * - status=1: 不同步（未支付）
   * - status=2-6 且无退款: 待上课
   * - status=7 且无退款: 已完成
   * - status=8,9,-1 或 refund=2 或 refund_status=1: 已退款
   */
  private mapOrderStatus(haimianOrder: HaimianOrder): string {
    // 安全处理数字字段
    const status = haimianOrder.status != null ? haimianOrder.status : null;
    const refund = haimianOrder.refund != null ? haimianOrder.refund : null;
    const refundStatus = haimianOrder.refund_status != null ? haimianOrder.refund_status : null;

    // 检查退款状态
    if (
      refund === 2 || // 已退款
      refundStatus === 1 || // 退款通过
      [8, 9, -1].includes(status) // 订单关闭/取消
    ) {
      return '已退款';
    }

    // 根据订单状态映射
    if (status === 7) {
      return '已完成';
    }

    if ([2, 3, 4, 5, 6].includes(status)) {
      return '待上课';
    }

    // 默认
    return '待上课';
  }

  /**
   * 直接创建或查找客户（简化逻辑）
   */
  private async findOrCreateCustomer(
    haimianOrder: HaimianOrder,
    options: { syncCustomerInfo: boolean; autoCreateCampus: boolean },
  ): Promise<Customer> {
    // 首先尝试通过订单号查找已存在的客户
    let customer = await this.findCustomerByOrderId(
      haimianOrder.order_id,
      haimianOrder.member?.mobile,
      haimianOrder.member?.nick_name
    );

    // 如果找不到客户，直接创建
    if (!customer) {
      const defaultSalesIdConfig = await this.businessConfigService.getConfig('order_sync.default_sales_id') || '1';
      const defaultSalesId = !isNaN(parseInt(defaultSalesIdConfig)) ? parseInt(defaultSalesIdConfig) : 1;

      customer = this.customerRepository.create({
        wechatId: `HM_${haimianOrder.member_id}_${Date.now()}`, // 生成唯一微信ID
        wechatNickname: haimianOrder.member?.nick_name || `海绵用户_${haimianOrder.member?.mobile?.slice(-4) || '未知'}`,
        phone: haimianOrder.member?.mobile || '',
        realName: haimianOrder.member?.realname || haimianOrder.member?.nick_name || '', // 优先使用真实姓名，否则使用微信昵称
        source: '海绵青年GO',
        salesId: defaultSalesId,
        externalOrderIds: [haimianOrder.order_id], // 直接绑定订单号
        customerIntent: '高意向', // 已付费客户，标记为高意向
        lifecycleStage: '成交客户',
      });

      await this.customerRepository.save(customer);
      this.logger.log(`直接创建客户: ${customer.wechatNickname}, 手机: ${haimianOrder.member?.mobile}, 订单: ${haimianOrder.order_id}`);
    } else {
      // 如果找到客户，更新externalOrderIds（如果不包含当前订单号）
      if (!customer.externalOrderIds) {
        customer.externalOrderIds = [];
      }
      if (!customer.externalOrderIds.includes(haimianOrder.order_id)) {
        customer.externalOrderIds.push(haimianOrder.order_id);
        await this.customerRepository.save(customer);
        this.logger.log(`为客户绑定订单号: ${customer.wechatNickname}, 订单: ${haimianOrder.order_id}`);
      }
    }

    return customer;
  }

  /**
   * 通过订单号查找客户（支持多种匹配方式）
   */
  private async findCustomerByOrderId(orderId: string, memberMobile?: string, memberNickname?: string): Promise<Customer | null> {
    // 首先尝试通过externalOrderIds字段查找
    const customers = await this.customerRepository.find({
      where: {
        // @ts-ignore
        externalOrderIds: Like(`%${orderId}%`),
      },
    });

    // 进一步精确匹配（避免误匹配）
    for (const customer of customers) {
      if (Array.isArray(customer.externalOrderIds) && customer.externalOrderIds.includes(orderId)) {
        this.logger.log(`通过externalOrderIds找到客户: ${customer.wechatNickname}, 订单: ${orderId}`);
        return customer;
      }
    }

    // 如果通过externalOrderIds找不到，尝试通过手机号匹配
    if (memberMobile) {
      const customerByPhone = await this.customerRepository.findOne({
        where: { phone: memberMobile },
      });
      if (customerByPhone) {
        this.logger.log(`通过手机号找到客户: ${customerByPhone.wechatNickname}, 手机: ${memberMobile}, 订单: ${orderId}`);
        return customerByPhone;
      }
    }

    // 如果通过手机号也找不到，尝试通过微信昵称模糊匹配
    if (memberNickname) {
      const customerByNickname = await this.customerRepository.findOne({
        where: {
          wechatNickname: memberNickname,
        },
      });
      if (customerByNickname) {
        this.logger.log(`通过微信昵称找到客户: ${customerByNickname.wechatNickname}, 订单: ${orderId}`);
        return customerByNickname;
      }
    }

    // 如果都找不到，返回null
    this.logger.warn(`未找到关联订单 ${orderId} 的客户记录 (手机: ${memberMobile}, 昵称: ${memberNickname})`);
    return null;
  }

  /**
   * 记录同步日志
   */
  private async logSync(data: {
    syncBatchId: string;
    orderNo: string;
    syncType: string;
    oldStatus?: string;
    newStatus?: string;
    changes?: any;
    externalData?: any;
    result: string;
    errorMessage?: string;
    executionTime: number;
  }): Promise<void> {
    const log = this.syncLogRepository.create(data);
    await this.syncLogRepository.save(log);
  }

  /**
   * 查询同步日志
   */
  async getSyncLogs(query: SyncLogQueryDto) {
    const page = query.page || 1;
    const pageSize = query.pageSize || 20;

    const where: any = {};
    if (query.syncBatchId) where.syncBatchId = query.syncBatchId;
    if (query.orderNo) where.orderNo = Like(`%${query.orderNo}%`);
    if (query.syncType) where.syncType = query.syncType;
    if (query.result) where.result = query.result;

    const [logs, total] = await this.syncLogRepository.findAndCount({
      where,
      order: { syncTime: 'DESC' },
      skip: (page - 1) * pageSize,
      take: pageSize,
    });

    return {
      list: logs,
      total,
      page,
      pageSize,
    };
  }

  /**
   * 获取同步配置
   */
  async getSyncConfig() {
    const config = await this.businessConfigService.findAll('order_sync');
    return config;
  }

  /**
   * 更新同步配置
   */
  async updateSyncConfig(configKey: string, configValue: string) {
    // 将前端驼峰命名转换为数据库下划线命名
    const dbConfigKey = this.mapConfigKeyToDb(configKey);
    return this.businessConfigService.updateConfig(dbConfigKey, configValue);
  }

  /**
   * 将前端配置键映射到数据库配置键
   */
  private mapConfigKeyToDb(configKey: string): string {
    const keyMapping: { [key: string]: string } = {
      'order_sync.apiKey': 'order_sync.api_key',
      'order_sync.apiUrl': 'order_sync.api_url',
      'order_sync.defaultSalesId': 'order_sync.default_sales_id',
      'order_sync.enabled': 'order_sync.enabled',
      'order_sync.interval': 'order_sync.interval',
      'order_sync.dailyUpdateTime': 'order_sync.daily_update_time',
      'order_sync.syncRangeDays': 'order_sync.sync_range_days',
      'order_sync.batchSize': 'order_sync.batch_size',
      'order_sync.updateExisting': 'order_sync.update_existing',
      'order_sync.syncCustomerInfo': 'order_sync.sync_customer_info',
      'order_sync.autoCreateCampus': 'order_sync.auto_create_campus',
    };

    return keyMapping[configKey] || configKey;
  }

  /**
   * 格式化日期为 YYYYMMDD
   */
  private formatDate(date: Date): string {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}${month}${day}`;
  }

  /**
   * 解析海绵API返回的时间字符串
   * 支持多种格式：YYYY-MM-DD HH:mm:ss、YYYY/MM/DD HH:mm:ss、时间戳等
   */
  private parseHaimianDateTime(timeStr?: string): Date | null {
    if (!timeStr) {
      return null;
    }

    try {
      // 如果是纯数字，可能是时间戳（秒或毫秒）
      if (/^\d+$/.test(timeStr)) {
        const timestamp = parseInt(timeStr);
        // 判断是秒还是毫秒：如果大于10^12，认为是毫秒；否则是秒
        const timeInMs = timestamp > 1e12 ? timestamp : timestamp * 1000;
        const date = new Date(timeInMs);
        // 验证日期是否有效
        if (isNaN(date.getTime()) || date.getFullYear() < 2000 || date.getFullYear() > 2030) {
          this.logger.warn(`无效的时间戳: ${timeStr}, 解析结果: ${date.toISOString()}`);
          return null;
        }
        return date;
      }

      // 尝试解析标准日期格式
      const date = new Date(timeStr);
      if (!isNaN(date.getTime()) && date.getFullYear() >= 2000 && date.getFullYear() <= 2030) {
        return date;
      }

      // 尝试解析 YYYYMMDD 格式
      if (/^\d{8}$/.test(timeStr)) {
        const year = parseInt(timeStr.substring(0, 4));
        const month = parseInt(timeStr.substring(4, 6)) - 1; // JS月份从0开始
        const day = parseInt(timeStr.substring(6, 8));
        const parsedDate = new Date(year, month, day);
        if (!isNaN(parsedDate.getTime())) {
          return parsedDate;
        }
      }

      // 尝试解析常见格式
      const formats = [
        /^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})$/,  // YYYY-MM-DD HH:mm:ss
        /^(\d{4})\/(\d{2})\/(\d{2}) (\d{2}):(\d{2}):(\d{2})$/,  // YYYY/MM/DD HH:mm:ss
        /^(\d{4})-(\d{2})-(\d{2})$/,                          // YYYY-MM-DD
        /^(\d{4})\/(\d{2})\/(\d{2})$/,                          // YYYY/MM/DD
      ];

      for (const format of formats) {
        const match = timeStr.match(format);
        if (match) {
          const year = parseInt(match[1]);
          const month = parseInt(match[2]) - 1;
          const day = parseInt(match[3]);
          const hour = match[4] ? parseInt(match[4]) : 0;
          const minute = match[5] ? parseInt(match[5]) : 0;
          const second = match[6] ? parseInt(match[6]) : 0;

          const parsedDate = new Date(year, month, day, hour, minute, second);
          if (!isNaN(parsedDate.getTime()) && parsedDate.getFullYear() >= 2000 && parsedDate.getFullYear() <= 2030) {
            return parsedDate;
          }
        }
      }

      this.logger.warn(`无法解析时间格式: ${timeStr}`);
      return null;
    } catch (error) {
      this.logger.error(`解析时间字符串失败: ${timeStr}`, error);
      return null;
    }
  }
}
